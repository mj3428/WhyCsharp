# CLR的执行模式
## 执行程序集的代码
托管程序集同时包含元数据和IL。IL是与CPU无关的机器语言。IL比大多数CPU机器语言都高级.IL能访问和操作对象类型，并提供了指令来创建和初始化对象、
调用对象上的虚方法以及直接操作数组元素。甚至提供了抛出和捕捉异常的指令来实现错误处理。  

*注:* 高级语言通常只公开了CLR全部功能的一个子集。然而，IL汇编语言允许开发人员访问CLR的全部功能。所以如果你选择的编程语言隐藏了你迫切需要的
CLR功能，可以换用IL汇编语言或者提供了所需的功能的另一种编程语言来写那部分代码。  

Main方法首次调用WriteLine时，JITComplier函数会被调用。JITComplier函数负责将方法的IL代码编译成本机CPU指令。JITComplier函数被调用时，它知道
要调用的时哪个方法，以及具体时神类型定义了改方法。然后,JITComplier会在定义程序集的元数据种查找被调用方法的IL。接着，JITComplier验证IL代码，
并将IL代码编译成本机CPU指令。本机cpu指令保存到动态分配的内存块种。然后，JITComplier回到CLR为类型创建的内部数据结构，找到与被调用方法对应的
那条记录，修改最初对JITComplier的引用，使其指向内存块（包括刚才编译好的本机cpu指令）的地址。最后JITComplier函数跳转到内存块种的代码。**这就是
Writeline方法的具体实现。**  

重要的是，由于已对writeline的代码进行了验证和编译，会直接执行内存块中的代码，完全跳过JITComplier函数。  

上述提过，JIT编译器将本机CPU指令存到动态内存中，即，应用程序终止，编译好的代码也会被丢弃

**运行时的二次编译确实会影响性能，也趋势会分配动态内存** 但是MSOFT进行了大量的性能优化工作，将这些额外的开销保持在最低限度之内  

IL最大的又是不是它对底层CPU的抽象，而是应用程序的健壮性和安全性。将IL编译成本机CPU指令时，CLR执行一个名为**验证** 的过程。确定代码所
做的一切都是安全的。  

WIN中的每个进程都有自己的虚拟地址空间，独立地址空间之所以必要，是因为不能简单地信任一个应用程序的代码。应用程序完全可能读写无效的内存地址。  

> 有必要强调健壮性（鲁棒性）与可靠性的区别，两者对应的英文单词分别是robustness和reliability。鲁棒性主要描述系统对与参数变化的不敏感性，而
可靠性主要描述系统的正确性，也就是在你固定提供一个参数时，他应该产生稳定的、能预测的输出。例如，一个程序，它的设计目标是获取输入并输出值。
假如它能正确完成这个设计目标，就说它是可靠的。但在这个程序执行完毕后，假如没有正确释放内存，或者说系统没有自动帮它释放占用的资源，就认为
这个程序及其“运行时"不健壮（不鲁棒）  

